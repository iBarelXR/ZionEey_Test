<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Cube Interaction</title>
    <style>
        body { margin: 0; background-color: #333; color: white; font-family: sans-serif; }
        #overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        button { padding: 20px 40px; font-size: 24px; background: #2c6ce7; color: white; border: none; border-radius: 10px; cursor: pointer; }
        p { margin-top: 10px; font-size: 18px; }
    </style>
</head>
<body>

    <div id="overlay">
        <button id="ar-button">Start AR</button>
        <p>Touch & Drag to Rotate</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let renderer, scene, camera;
        let cube;
        let controllers = [];
        let hands = [];
        
        // State for interaction
        let previousPosition = new THREE.Vector3();
        let isInteracting = false;
        
        // Raycaster for controllers
        const raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();

        document.getElementById('ar-button').addEventListener('click', async () => {
            if (navigator.xr) {
                const session = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local-floor'],
                    optionalFeatures: ['hand-tracking']
                });
                onSessionStarted(session);
            }
        });

        function onSessionStarted(session) {
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local-floor');
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            // Create Cube
            // We use MeshLambertMaterial so it reacts to light (looks more 3D)
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); 
            cube = new THREE.Mesh(geometry, material);
            cube.position.set(0, 1.5, -0.8);
            scene.add(cube);

            // Add a light so the cube isn't flat
            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(1, 2, 1);
            scene.add(light);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);

            setupInputs();

            renderer.xr.setSession(session);
            renderer.setAnimationLoop(render);
            document.getElementById('overlay').style.display = 'none';
        }

        function setupInputs() {
            const controllerModelFactory = new XRControllerModelFactory();
            const handModelFactory = new XRHandModelFactory();

            for (let i = 0; i < 2; i++) {
                // Controller
                const controller = renderer.xr.getController(i);
                // Visual Line
                const line = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]),
                    new THREE.LineBasicMaterial({ color: 0xffffff })
                );
                controller.add(line);
                controller.userData.ray = line;
                // Track button presses
                controller.addEventListener('selectstart', () => { controller.userData.isSelecting = true; });
                controller.addEventListener('selectend', () => { controller.userData.isSelecting = false; });
                
                scene.add(controller);
                controllers.push(controller);

                // Hand
                const hand = renderer.xr.getHand(i);
                hand.add(handModelFactory.createHandModel(hand, "mesh"));
                scene.add(hand);
                hands.push(hand);
            }
        }

        function render() {
            let activeInputPosition = null;

            // 1. CHECK CONTROLLERS (Laser)
            controllers.forEach((controller) => {
                if (controller.userData.isSelecting) {
                    // Raycast to find intersection
                    tempMatrix.identity().extractRotation(controller.matrixWorld);
                    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                    const intersects = raycaster.intersectObject(cube);
                    if (intersects.length > 0) {
                        activeInputPosition = intersects[0].point;
                    }
                }
            });

            // 2. CHECK HANDS (Direct Touch)
            // If no controller interaction, check hands
            if (!activeInputPosition) {
                hands.forEach((hand) => {
                    if (hand.visible) {
                        const indexTip = hand.getObjectByName('index-finger-tip');
                        if (indexTip) {
                            const tipPos = new THREE.Vector3();
                            indexTip.getWorldPosition(tipPos);
                            
                            // Check distance to cube center
                            const dist = tipPos.distanceTo(cube.position);
                            // 0.13 is roughly "touching" the surface (cube is 0.2 wide)
                            if (dist < 0.13) {
                                activeInputPosition = tipPos;
                            }
                        }
                    }
                });
            }

            // 3. APPLY ROTATION LOGIC
            if (activeInputPosition) {
                // Interaction JUST started this frame
                if (!isInteracting) {
                    isInteracting = true;
                    previousPosition.copy(activeInputPosition);
                    cube.material.color.setHex(0x0000ff); // Turn BLUE on touch
                } 
                // Interaction is continuing
                else {
                    // Calculate how much the hand/laser moved
                    const deltaX = activeInputPosition.x - previousPosition.x;
                    const deltaY = activeInputPosition.y - previousPosition.y;

                    // Rotate cube based on that movement (sensitivity 5.0)
                    cube.rotation.y += deltaX * 5.0;
                    cube.rotation.x += deltaY * 5.0;

                    // Update previous position for next frame
                    previousPosition.copy(activeInputPosition);
                }
            } else {
                // No interaction this frame
                if (isInteracting) {
                    isInteracting = false;
                    cube.material.color.setHex(0xff0000); // Back to RED
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
