<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Quest 3 AR: Red vs Blue</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- A-Frame 1.5.0 -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- Firebase Libraries -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

    <style>
        body { font-family: sans-serif; background-color: transparent; }
        
        .a-enter-vr { position: fixed; bottom: 20px; right: 20px; z-index: 9999; }
        
        #overlay {
            position: absolute; z-index: 1000; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: white; display: flex; flex-direction: column;
            align-items: center; justify-content: center; text-align: center;
            pointer-events: auto;
        }
        .btn {
            background: #444; color: white; border: 2px solid white; padding: 15px 30px;
            font-size: 1.2rem; margin: 10px; cursor: pointer; border-radius: 8px;
        }
        .btn-blue { background: #0055ff; border-color: #002a80; }
        .btn-red { background: #d32f2f; border-color: #8e0000; }
        .hidden { display: none !important; }
        #status { 
            position: absolute; bottom: 20px; left: 20px; color: lime; 
            z-index: 999; font-weight: bold; text-shadow: 1px 1px 2px black; font-family: monospace; font-size: 1.2em;
            pointer-events: none;
        }
        .calibration-instruction {
            background: rgba(255, 255, 0, 0.2);
            border: 1px solid yellow;
            padding: 10px; margin-bottom: 20px; border-radius: 5px; max-width: 80%;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>Quest 3 AR Battle</h1>
        <div class="calibration-instruction">
            <h3>ðŸŽ¯ Troubleshooting</h3>
            <p><strong>Can't see the yellow box?</strong><br>1. Look for the GREEN LINE coming from your right hand.<br>2. Press <strong>'A'</strong> or <strong>'X'</strong> to summon the box to your face.</p>
        </div>
        <div id="setup-controls">
            <button class="btn btn-blue" onclick="startAR('blue')">Join Blue Team</button>
            <button class="btn btn-red" onclick="startAR('red')">Join Red Team</button>
        </div>
        <p id="loading-text" class="hidden">Starting AR...</p>
    </div>

    <div id="status">Press 'A' to Summon World</div>

    <!-- 3D Scene -->
    <a-scene 
        renderer="alpha: true; antialias: true; colorManagement: true; sortObjects: true;"
        webxr="optionalFeatures: dom-overlay, hit-test, immersive-ar; overlayElement: #overlay; requiredFeatures: local-floor"
        vr-mode-ui="enabled: true"
        background="color: transparent">
        
        <a-sky color="#000000" opacity="0"></a-sky>
        <a-light type="ambient" intensity="2"></a-light>
        <a-light type="directional" intensity="1.5" position="-1 2 1"></a-light>

        <a-assets>
            <a-mixin id="blue-indicator" geometry="primitive: octahedron; radius: 0.15" material="shader: flat; color: #00aaff; opacity: 1.0; depthTest: false"></a-mixin>
            <a-mixin id="red-indicator" geometry="primitive: cone; radiusBottom: 0.01; radiusTop: 0.15; height: 0.3" material="shader: flat; color: #ff3333; opacity: 1.0; depthTest: false"></a-mixin>
        </a-assets>

        <!-- LOCAL PLAYER -->
        <a-entity id="local-rig">
            <a-camera id="local-head" position="0 1.6 0" look-controls="pointerLockEnabled: false"></a-camera>
            
            <a-entity id="left-hand" laser-controls="hand: left" calibration-listener></a-entity>
            
            <!-- Right Hand: Has the tether line to find the world -->
            <a-entity id="right-hand" laser-controls="hand: right" calibration-listener>
                <a-entity line="start: 0 0 0; end: 0 0 -10; color: lime; opacity: 0.5" id="guideline"></a-entity>
            </a-entity>
        </a-entity>


        <!-- WORLD ROOT -->
        <!-- Start slightly forward and up so it's likely in view -->
        <a-entity id="world-root" position="0 1.5 -1">
            
            <!-- Visual Marker -->
            <a-entity id="calibration-marker" visible="true">
                <a-box position="0 0 0" width="0.3" height="0.3" depth="0.3" material="shader: flat; color: yellow; opacity: 0.8; depthTest: false"></a-box>
                <a-text value="SYNC CENTER" align="center" position="0 0.25 0" scale="0.5 0.5 0.5" color="yellow" material="shader: flat; depthTest: false"></a-text>
                <a-cylinder height="0.01" radius="0.3" material="shader: flat; color: yellow; opacity: 0.3; depthTest: false"></a-cylinder>
            </a-entity>

            <a-entity id="remote-players"></a-entity>

        </a-entity>

        <a-entity id="sync-system" network-sync></a-entity>

    </a-scene>

    <script>
        // --- 0. CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyCgzwyHW0gPmsdp5sKFPL2WpUqah02OAf4",
            authDomain: "zioneye-prototype.firebaseapp.com",
            projectId: "zioneye-prototype",
            storageBucket: "zioneye-prototype.firebasestorage.app",
            messagingSenderId: "356865086206",
            appId: "1:356865086206:web:d611c8deb6a98070dc0baf",
            measurementId: "G-P1XL9VQN79"
        };

        let db, auth, currentUserId, myTeam = null;

        // --- 1. WEAPON MODELS ---
        function getWeaponContent(team) {
            if (team === 'blue') {
                return `
                    <a-box material="shader: flat; color: #1a1a1a" depth="0.4" height="0.08" width="0.05" position="0 0 -0.1"></a-box>
                    <a-cylinder material="shader: flat; color: #111" height="0.35" radius="0.015" rotation="90 0 0" position="0 0.02 -0.35"></a-cylinder>
                    <a-box material="shader: flat; color: #222" depth="0.05" height="0.2" width="0.04" position="0 -0.12 -0.1" rotation="10 0 0"></a-box>
                `; 
            } else {
                return `
                    <a-box material="shader: flat; color: #2a2a2a" depth="0.4" height="0.08" width="0.05" position="0 0 -0.1"></a-box>
                    <a-box material="shader: flat; color: #8B4513" depth="0.2" height="0.06" width="0.055" position="0 0 -0.3"></a-box>
                    <a-cylinder material="shader: flat; color: #111" height="0.4" radius="0.012" rotation="90 0 0" position="0 0.02 -0.4"></a-cylinder>
                `;
            }
        }

        // --- 2. CONTROLS ---
        AFRAME.registerComponent('calibration-listener', {
            init: function () {
                this.el.addEventListener('triggerdown', this.syncToMarker.bind(this));
                this.el.addEventListener('abuttondown', this.summonWorld.bind(this));
                this.el.addEventListener('xbuttondown', this.summonWorld.bind(this));
            },
            
            tick: function() {
                // Update the Green Guideline to point to the world root
                const guide = document.getElementById('guideline');
                const root = document.getElementById('world-root');
                const hand = document.getElementById('right-hand');
                if(guide && root && hand) {
                    // Convert root position to hand local space is complex, 
                    // simpler to just update line 'end' attribute in world space if using a-frame line component?
                    // Actually, simpler: Put a sphere at world root.
                    // The line is just a visual aid. Let's make it fixed length for now.
                }
            },

            summonWorld: function() {
                const worldRoot = document.getElementById('world-root');
                const camera = document.getElementById('local-head');
                
                // Teleport World Root 1m in front of camera
                const camPos = new THREE.Vector3();
                const camQuat = new THREE.Quaternion();
                camera.object3D.getWorldPosition(camPos);
                camera.object3D.getWorldQuaternion(camQuat);
                
                const direction = new THREE.Vector3(0, 0, -1.0);
                direction.applyQuaternion(camQuat);
                direction.y = 0; 
                
                const newPos = new THREE.Vector3().copy(camPos).add(direction);
                newPos.y = camPos.y; // Keep height relative to head
                
                worldRoot.object3D.position.copy(newPos);
                
                // Rotate to face user
                const euler = new THREE.Euler().setFromQuaternion(camQuat, 'YXZ');
                worldRoot.object3D.rotation.set(0, euler.y, 0);

                this.showStatus("World Summoned!");
            },

            syncToMarker: function () {
                const worldRoot = document.getElementById('world-root');
                const controller = this.el.object3D;
                
                controller.updateMatrixWorld(true);
                worldRoot.object3D.position.copy(controller.position);
                worldRoot.object3D.rotation.set(0, controller.rotation.y, 0); 

                this.showStatus("Synced to Controller!");
            },
            
            showStatus: function(msg) {
                const status = document.getElementById('status');
                status.innerText = msg;
                status.style.color = "lime";
                setTimeout(() => status.innerText = "Press 'A' to Summon | Trigger to Sync", 3000);
            }
        });

        // --- 3. NETWORK SYNC ---
        AFRAME.registerComponent('network-sync', {
            init: function() { this.lastTime = 0; },
            tick: function () {
                if (!currentUserId || !db) return;
                const now = Date.now();
                if (now - this.lastTime < 80) return; 
                this.lastTime = now;

                const head = document.getElementById('local-head');
                const hand = document.getElementById('right-hand');
                const worldRoot = document.getElementById('world-root');

                head.object3D.updateMatrixWorld(true);
                hand.object3D.updateMatrixWorld(true);
                worldRoot.object3D.updateMatrixWorld(true);

                const rootInv = new THREE.Matrix4().copy(worldRoot.object3D.matrixWorld).invert();
                
                // Head Relative
                const headWorld = head.object3D.matrixWorld;
                const headRel = new THREE.Matrix4().multiplyMatrices(rootInv, headWorld);
                const hPos = new THREE.Vector3(); const hQuat = new THREE.Quaternion(); const hScale = new THREE.Vector3();
                headRel.decompose(hPos, hQuat, hScale);
                const hRot = new THREE.Euler().setFromQuaternion(hQuat);

                // Hand Relative
                const handWorld = hand.object3D.matrixWorld;
                const handRel = new THREE.Matrix4().multiplyMatrices(rootInv, handWorld);
                const wPos = new THREE.Vector3(); const wQuat = new THREE.Quaternion(); const wScale = new THREE.Vector3();
                handRel.decompose(wPos, wQuat, wScale);
                const wRot = new THREE.Euler().setFromQuaternion(wQuat);

                db.collection('players').doc(currentUserId).update({
                    x: hPos.x, y: hPos.y, z: hPos.z,
                    rotX: hRot.x, rotY: hRot.y, rotZ: hRot.z,
                    handX: wPos.x, handY: wPos.y, handZ: wPos.z,
                    handRotX: wRot.x, handRotY: wRot.y, handRotZ: wRot.z,
                    lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
        });

        // --- 4. STARTUP ---
        function initFirebase() {
            if (!firebase.apps.length) {
                try {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    auth = firebase.auth();
                    return true;
                } catch (e) { console.error(e); return false; }
            }
            return true;
        }

        async function startAR(team) {
            document.getElementById('setup-controls').classList.add('hidden');
            document.getElementById('loading-text').classList.remove('hidden');

            // 1. Launch AR
            const scene = document.querySelector('a-scene');
            if (navigator.xr) {
                try {
                    const session = await navigator.xr.requestSession('immersive-ar', {
                        optionalFeatures: ['dom-overlay', 'hit-test', 'local-floor'],
                        domOverlay: { root: document.body } 
                    });
                    scene.renderer.xr.setSession(session);
                } catch (e) {
                    console.warn("AR Launch Failed, fallback VR", e);
                    scene.enterVR(); 
                }
            } else { scene.enterVR(); }

            // 2. Auth & Spawn
            if (!initFirebase()) return;
            try {
                const userCred = await auth.signInAnonymously();
                currentUserId = userCred.user.uid;
                myTeam = team;

                // Local Weapon
                const hand = document.getElementById('right-hand');
                while (hand.firstChild) { hand.removeChild(hand.firstChild); }
                const weapon = document.createElement('a-entity');
                weapon.innerHTML = getWeaponContent(team);
                weapon.setAttribute('rotation', '-10 0 0');
                hand.appendChild(weapon);

                // Add Guide Line to Right Hand
                const line = document.createElement('a-entity');
                line.setAttribute('id', 'guideline');
                line.setAttribute('line', 'start: 0 0 0; end: 0 0 -1; color: lime');
                hand.appendChild(line);

                await db.collection('players').doc(currentUserId).set({
                    team: team, x:0, y:0, z:0, active: true,
                    lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
                });

                db.collection('players').onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(change => {
                        if (change.doc.id === currentUserId) return;
                        if (change.type === 'added') createRemotePlayer(change.doc.id, change.doc.data());
                        if (change.type === 'modified') updateRemotePlayer(change.doc.id, change.doc.data());
                        if (change.type === 'removed') removeRemotePlayer(change.doc.id);
                    });
                });
                
                document.getElementById('overlay').style.display = 'none';
            } catch (error) {
                alert("Error: " + error.message);
                document.getElementById('overlay').style.display = 'flex';
                document.getElementById('setup-controls').classList.remove('hidden');
            }
        }

        // --- 5. REMOTE ---
        function createRemotePlayer(id, data) {
            const container = document.getElementById('remote-players');
            const el = document.createElement('a-entity');
            el.setAttribute('id', `player-${id}`);

            const indicator = document.createElement('a-entity');
            indicator.classList.add('indicator-head'); 
            
            if (data.team === 'blue') {
                indicator.setAttribute('mixin', 'blue-indicator');
                indicator.setAttribute('position', '0 0.5 0'); 
                if (myTeam === 'red') indicator.setAttribute('visible', false);
            } else {
                indicator.setAttribute('mixin', 'red-indicator');
                indicator.setAttribute('position', '0 0.5 0'); 
                indicator.setAttribute('visible', true);
            }
            el.appendChild(indicator);

            const handEnt = document.createElement('a-entity');
            handEnt.classList.add('remote-hand');
            const weaponEnt = document.createElement('a-entity');
            weaponEnt.innerHTML = getWeaponContent(data.team);
            weaponEnt.setAttribute('rotation', '-10 0 0');
            handEnt.appendChild(weaponEnt);
            el.appendChild(handEnt);

            container.appendChild(el);
        }

        function updateRemotePlayer(id, data) {
            const el = document.getElementById(`player-${id}`);
            if (el) {
                el.object3D.position.set(0, 0, 0);
                el.object3D.rotation.set(0, 0, 0);

                const indicator = el.querySelector('.indicator-head');
                if (indicator) {
                     indicator.object3D.position.set(data.x, data.y, data.z);
                     indicator.object3D.rotation.set(0, data.rotY, 0); 
                     if (data.team !== 'blue') indicator.object3D.rotation.x = Math.PI; 
                }
                const hand = el.querySelector('.remote-hand');
                if (hand && data.handX !== undefined) {
                    hand.object3D.position.set(data.handX, data.handY, data.handZ);
                    hand.object3D.rotation.set(data.handRotX, data.handRotY, data.handRotZ);
                }
            }
        }

        function removeRemotePlayer(id) {
            const el = document.getElementById(`player-${id}`);
            if (el) el.remove();
        }
    </script>
</body>
</html>
