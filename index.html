<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Hand Interaction</title>
    <style>
        body { margin: 0; background-color: #333; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        #ar-button { padding: 20px 40px; font-size: 24px; background: #2c6ce7; color: white; border: none; border-radius: 10px; cursor: pointer; }
        p { margin-top: 10px; opacity: 0.8; max-width: 400px; text-align: center; }
    </style>
</head>
<body>

    <button id="ar-button">Start Hand AR</button>
    <p>1. Pinch fingers to use "Laser" from far away.<br>2. Reach out and touch the cube to spin it.</p>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let renderer, scene, camera;
        let cube;
        let controllers = [];
        let hands = [];
        const raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();

        // Button Logic
        const button = document.getElementById('ar-button');
        button.addEventListener('click', async () => {
            if (navigator.xr) {
                try {
                    const session = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['local-floor'],
                        optionalFeatures: ['hand-tracking'] // CRITICAL for hands
                    });
                    onSessionStarted(session);
                } catch (e) {
                    alert("Error: " + e);
                }
            } else {
                alert("WebXR not found.");
            }
        });

        function onSessionStarted(session) {
            // 1. Setup Renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local-floor');
            document.body.appendChild(renderer.domElement);

            // 2. Setup Scene
            scene = new THREE.Scene();

            // 3. Create the Cube
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2); 
            const material = new THREE.MeshNormalMaterial(); // Uses colors based on angle, looks better for rotation
            cube = new THREE.Mesh(geometry, material);
            cube.position.set(0, 1.6, -1); // 1.6m high, 1m forward
            scene.add(cube);

            // 4. Setup Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);

            // 5. Setup Controllers (Rays) & Hands (Meshes)
            setupControllers();

            // 6. Loop
            renderer.xr.setSession(session);
            renderer.setAnimationLoop(render);
        }

        function setupControllers() {
            const controllerModelFactory = new XRControllerModelFactory();
            const handModelFactory = new XRHandModelFactory();

            // We need to handle 2 input sources (left/right)
            for (let i = 0; i < 2; i++) {
                // --- Ray / Controller Logic ---
                const controller = renderer.xr.getController(i);
                
                // Add a visual "Laser" line
                const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -5)]);
                const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffffff }));
                line.scale.z = 0; // Hide initially
                controller.add(line);
                controller.userData.line = line;
                
                // Track pinch state
                controller.addEventListener('selectstart', () => { controller.userData.isSelecting = true; });
                controller.addEventListener('selectend', () => { controller.userData.isSelecting = false; });
                
                scene.add(controller);
                controllers.push(controller);

                // --- Visual Hand Mesh ---
                const hand = renderer.xr.getHand(i);
                hand.add(handModelFactory.createHandModel(hand, "mesh")); // "mesh" or "boxes" or "spheres"
                scene.add(hand);
                hands.push(hand);
            }
        }

        function render() {
            // Check interactions for both hands
            controllers.forEach((controller, index) => {
                const hand = hands[index];
                
                // 1. DIRECT TOUCH CHECK (Distance based)
                // We use the 'index-finger-tip' joint if available, or just the controller position as fallback
                let touchPosition = controller.position;
                
                // Try to find the actual finger tip in the hand model hierarchy
                if (hand.children.length > 0) {
                     const indexTip = hand.getObjectByName('index-finger-tip');
                     if (indexTip) {
                         // We must get the world position of the joint
                         indexTip.getWorldPosition(tempMatrix.position); // Re-using tempMatrix just for vector storage
                         touchPosition = tempMatrix.position; 
                     }
                }

                // Distance from finger tip to cube center
                const distanceToCube = touchPosition.distanceTo(cube.position);
                
                // If touching (within 15cm radius), rotate fast!
                if (distanceToCube < 0.15) {
                    cube.rotation.x += 0.05;
                    cube.rotation.y += 0.05;
                    cube.material.wireframe = true; // Visual feedback
                } else {
                    cube.material.wireframe = false;
                }

                // 2. LASER CHECK (Raycasting)
                // Position the raycaster at the controller/wrist position, pointing forward
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                const intersects = raycaster.intersectObject(cube);

                if (intersects.length > 0) {
                    // Show full laser length if hitting
                    controller.userData.line.scale.z = intersects[0].distance;
                    
                    // If pinching ("selecting"), rotate the cube
                    if (controller.userData.isSelecting) {
                        cube.rotation.y -= 0.05;
                    }
                } else {
                    // Short guidance laser if not hitting anything
                    controller.userData.line.scale.z = 0.5; // 50cm guide line
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
