<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Quest 3 AR: Red vs Blue</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- A-Frame 1.5.0 -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- Firebase Libraries -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

    <style>
        body { font-family: sans-serif; background-color: #000; }
        #overlay {
            position: absolute; z-index: 1000; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: white; display: flex; flex-direction: column;
            align-items: center; justify-content: center; text-align: center;
        }
        .btn {
            background: #444; color: white; border: 2px solid white; padding: 15px 30px;
            font-size: 1.2rem; margin: 10px; cursor: pointer; border-radius: 8px;
        }
        .btn-blue { background: #0055ff; border-color: #002a80; }
        .btn-red { background: #d32f2f; border-color: #8e0000; }
        .hidden { display: none !important; }
        #status { 
            position: absolute; bottom: 20px; left: 20px; color: lime; 
            z-index: 999; font-weight: bold; text-shadow: 1px 1px 2px black; font-family: monospace; font-size: 1.2em;
        }
        .calibration-instruction {
            background: rgba(255, 255, 0, 0.2);
            border: 1px solid yellow;
            padding: 10px; margin-bottom: 20px; border-radius: 5px; max-width: 80%;
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div id="overlay">
        <h1>Quest 3 AR Battle</h1>
        
        <div class="calibration-instruction">
            <h3>ðŸŽ¯ Precision Calibration</h3>
            <p>1. Stick a marker (QR Code or X) on a wall or table.</p>
            <p>2. Hold your <strong>RIGHT Controller</strong> against the marker.</p>
            <p>3. Press <strong>TRIGGER</strong> to snap the world to that point.</p>
        </div>
        
        <div id="setup-controls">
            <button class="btn btn-blue" onclick="startAR('blue')">Join Blue Team (M4)</button>
            <button class="btn btn-red" onclick="startAR('red')">Join Red Team (AK47)</button>
        </div>
        <p id="loading-text" class="hidden">Requesting AR Session...</p>
    </div>

    <div id="status">Hold Right Controller on Marker & Pull Trigger</div>

    <!-- 3D Scene -->
    <!-- Note: We use a transparent background and hidden VR UI to force our own flow -->
    <a-scene 
        renderer="alpha: true; antialias: true; colorManagement: true; sortObjects: true;"
        webxr="optionalFeatures: dom-overlay, hit-test; overlayElement: #status; requiredFeatures: local-floor"
        vr-mode-ui="enabled: false"
        background="color: transparent">
        
        <a-assets>
            <!-- Blue Diamond (Static, pointing down logic handled in entity) -->
            <a-mixin id="blue-indicator" geometry="primitive: octahedron; radius: 0.15" material="color: #00aaff; shader: flat; opacity: 0.9"></a-mixin>
            <!-- Red Triangle (Points Down) -->
            <a-mixin id="red-indicator" geometry="primitive: cone; radiusBottom: 0.01; radiusTop: 0.15; height: 0.3" material="color: #ff3333; shader: flat; opacity: 0.9"></a-mixin>
        </a-assets>

        <!-- LOCAL PLAYER RIG -->
        <a-entity id="local-rig">
            <a-camera id="local-head" position="0 1.6 0" look-controls="pointerLockEnabled: false"></a-camera>
            
            <a-entity id="left-hand" laser-controls="hand: left" raycaster="showLine: false"></a-entity>
            
            <!-- Right Hand (Weapon + Calibration) -->
            <a-entity id="right-hand" laser-controls="hand: right" calibration-listener raycaster="showLine: false">
                <!-- Weapon spawned here -->
            </a-entity>
        </a-entity>


        <!-- WORLD ROOT (The Anchor) -->
        <a-entity id="world-root" position="0 0 0">
            
            <!-- Calibration Visual Marker -->
            <a-entity id="calibration-marker" visible="true">
                <a-box position="0 0 0" width="0.1" height="0.1" depth="0.1" color="yellow" wireframe="true"></a-box>
                <a-text value="SYNC POINT" align="center" position="0 0.2 0" scale="0.3 0.3 0.3" color="yellow"></a-text>
                <a-cylinder height="0.01" radius="0.2" color="yellow" opacity="0.3"></a-cylinder>
                <a-arrow direction="0 0 -1" length="0.5" color="yellow"></a-arrow>
            </a-entity>

            <!-- Remote Players -->
            <a-entity id="remote-players"></a-entity>

        </a-entity>

        <!-- SYNC SYSTEM (Custom component to handle per-frame updates) -->
        <a-entity id="sync-system" network-sync></a-entity>

    </a-scene>

    <script>
        // --- 0. CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyCgzwyHW0gPmsdp5sKFPL2WpUqah02OAf4",
            authDomain: "zioneye-prototype.firebaseapp.com",
            projectId: "zioneye-prototype",
            storageBucket: "zioneye-prototype.firebasestorage.app",
            messagingSenderId: "356865086206",
            appId: "1:356865086206:web:d611c8deb6a98070dc0baf",
            measurementId: "G-P1XL9VQN79"
        };

        let db, auth, currentUserId, myTeam = null;

        // --- 1. WEAPON MODELS ---
        function getWeaponContent(team) {
            if (team === 'blue') {
                return `
                    <a-box color="#1a1a1a" depth="0.4" height="0.08" width="0.05" position="0 0 -0.1"></a-box>
                    <a-cylinder color="#111" height="0.35" radius="0.015" rotation="90 0 0" position="0 0.02 -0.35"></a-cylinder>
                    <a-box color="#222" depth="0.05" height="0.2" width="0.04" position="0 -0.12 -0.1" rotation="10 0 0"></a-box>
                    <a-box color="#111" depth="0.15" height="0.1" width="0.04" position="0 -0.05 0.2"></a-box>
                    <a-box color="#444" depth="0.1" height="0.04" width="0.04" position="0 0.08 -0.1"></a-box>
                `; 
            } else {
                return `
                    <a-box color="#2a2a2a" depth="0.4" height="0.08" width="0.05" position="0 0 -0.1"></a-box>
                    <a-box color="#8B4513" depth="0.2" height="0.06" width="0.055" position="0 0 -0.3"></a-box>
                    <a-cylinder color="#111" height="0.4" radius="0.012" rotation="90 0 0" position="0 0.02 -0.4"></a-cylinder>
                    <a-box color="#333" depth="0.06" height="0.22" width="0.04" position="0 -0.12 -0.15" rotation="25 0 0"></a-box>
                    <a-box color="#8B4513" depth="0.2" height="0.1" width="0.04" position="0 -0.08 0.25" rotation="-15 0 0"></a-box>
                `;
            }
        }

        // --- 2. CALIBRATION (ONE-TIME SNAP) ---
        AFRAME.registerComponent('calibration-listener', {
            init: function () {
                this.el.addEventListener('triggerdown', this.calibrate.bind(this));
            },
            calibrate: function () {
                const worldRoot = document.getElementById('world-root');
                const controller = this.el.object3D;
                
                // Force update to get latest matrix
                controller.updateMatrixWorld(true);
                
                // Snap World Root to Controller
                const pos = controller.position;
                const rot = controller.rotation;
                
                worldRoot.object3D.position.set(pos.x, pos.y, pos.z);
                worldRoot.object3D.rotation.set(0, rot.y, 0); // Yaw align only

                // Visual Feedback
                const status = document.getElementById('status');
                status.innerText = "Synced! World moved to Marker.";
                status.style.color = "lime";
                
                // Flash Marker
                const marker = document.getElementById('calibration-marker');
                marker.setAttribute('visible', 'true');
            }
        });

        // --- 3. NETWORK SYNC SYSTEM (The "Tick" Loop) ---
        // This runs every frame (90/72 times a second) ensuring fresh data
        AFRAME.registerComponent('network-sync', {
            tick: function () {
                if (!currentUserId || !db) return;

                // Throttle sending to ~10 times per second to save bandwidth/DB costs
                // (High freq tick is for reading inputs, we limit the send rate)
                const now = Date.now();
                if (now - this.lastTime < 100) return; 
                this.lastTime = now;

                const head = document.getElementById('local-head');
                const hand = document.getElementById('right-hand');
                const worldRoot = document.getElementById('world-root');

                // Force Matrix Updates to ensure we aren't using stale data
                head.object3D.updateMatrixWorld(true);
                hand.object3D.updateMatrixWorld(true);
                worldRoot.object3D.updateMatrixWorld(true);

                // --- MATH: Calculate Local Position Relative to Anchor ---
                // We multiply the World Root's Inverse Matrix by the Object's World Matrix
                const rootInv = new THREE.Matrix4().copy(worldRoot.object3D.matrixWorld).invert();
                
                // Head
                const headWorld = head.object3D.matrixWorld;
                const headRel = new THREE.Matrix4().multiplyMatrices(rootInv, headWorld);
                const hPos = new THREE.Vector3(); const hQuat = new THREE.Quaternion(); const hScale = new THREE.Vector3();
                headRel.decompose(hPos, hQuat, hScale);
                const hRot = new THREE.Euler().setFromQuaternion(hQuat);

                // Hand
                const handWorld = hand.object3D.matrixWorld;
                const handRel = new THREE.Matrix4().multiplyMatrices(rootInv, handWorld);
                const wPos = new THREE.Vector3(); const wQuat = new THREE.Quaternion(); const wScale = new THREE.Vector3();
                handRel.decompose(wPos, wQuat, wScale);
                const wRot = new THREE.Euler().setFromQuaternion(wQuat);

                // Send to DB
                db.collection('players').doc(currentUserId).update({
                    x: hPos.x, y: hPos.y, z: hPos.z,
                    rotX: hRot.x, rotY: hRot.y, rotZ: hRot.z,
                    
                    handX: wPos.x, handY: wPos.y, handZ: wPos.z,
                    handRotX: wRot.x, handRotY: wRot.y, handRotZ: wRot.z,
                    
                    lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
        });

        // --- 4. SESSION START & LOGIC ---

        function initFirebase() {
            if (!firebase.apps.length) {
                try {
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    auth = firebase.auth();
                } catch (e) {
                    console.error("Firebase Init Error:", e);
                    return false;
                }
            }
            return true;
        }

        async function startAR(team) {
            if (!initFirebase()) return;
            
            document.getElementById('setup-controls').classList.add('hidden');
            document.getElementById('loading-text').classList.remove('hidden');

            try {
                // Auth
                const userCred = await auth.signInAnonymously();
                currentUserId = userCred.user.uid;
                myTeam = team;

                // Spawn Local Weapon
                const hand = document.getElementById('right-hand');
                const weapon = document.createElement('a-entity');
                weapon.innerHTML = getWeaponContent(team);
                weapon.setAttribute('rotation', '-10 0 0');
                hand.appendChild(weapon);

                // Init DB
                await db.collection('players').doc(currentUserId).set({
                    team: team,
                    x: 0, y: 0, z: 0, rotY: 0,
                    active: true,
                    lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Listen for Remote Players
                db.collection('players').onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(change => {
                        if (change.doc.id === currentUserId) return;
                        if (change.type === 'added') createRemotePlayer(change.doc.id, change.doc.data());
                        if (change.type === 'modified') updateRemotePlayer(change.doc.id, change.doc.data());
                        if (change.type === 'removed') removeRemotePlayer(change.doc.id);
                    });
                });

                document.getElementById('overlay').classList.add('hidden');

                // --- CRITICAL PASSTHROUGH FIX ---
                // We use standard A-Frame enterVR() but since we didn't add vr-mode-ui,
                // and the scene is configured for AR, A-Frame should try AR.
                // However, on Quest, sometimes explicit immersive-ar is safer.
                // The 'webxr' component on <a-scene> handles this mostly.
                // We force background clear.
                
                const scene = document.querySelector('a-scene');
                
                // This checks if AR is available and launches it
                if (navigator.xr) {
                    const isArSupported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (isArSupported) {
                        // We rely on A-Frame to handle the session creation
                        scene.enterVR(); 
                    } else {
                        alert("AR not supported on this device/browser.");
                    }
                } else {
                    scene.enterVR(); // Fallback
                }

            } catch (error) {
                console.error("Error:", error);
                alert("Error: " + error.message);
            }
        }

        // --- 5. REMOTE PLAYER VISUALS ---

        function createRemotePlayer(id, data) {
            const container = document.getElementById('remote-players');
            const el = document.createElement('a-entity');
            el.setAttribute('id', `player-${id}`);

            // 1. Team Indicator (Static, No Animation)
            const indicator = document.createElement('a-entity');
            
            // NOTE: We don't animate rotation anymore.
            if (data.team === 'blue') {
                indicator.setAttribute('mixin', 'blue-indicator');
                indicator.setAttribute('position', '0 0.5 0'); // Above head
                // Blue Diamond - Static
                if (myTeam === 'red') indicator.setAttribute('visible', false);
            } else {
                indicator.setAttribute('mixin', 'red-indicator');
                indicator.setAttribute('position', '0 0.5 0'); // Above head
                // Red Triangle - Points DOWN
                // The mixin has "180 0 0" rotation already, so the cone tip points down.
                indicator.setAttribute('visible', true);
            }
            el.appendChild(indicator);

            // 2. Weapon
            const handEnt = document.createElement('a-entity');
            handEnt.classList.add('remote-hand');
            const weaponEnt = document.createElement('a-entity');
            weaponEnt.innerHTML = getWeaponContent(data.team);
            weaponEnt.setAttribute('rotation', '-10 0 0');
            handEnt.appendChild(weaponEnt);
            el.appendChild(handEnt);

            container.appendChild(el);
        }

        function updateRemotePlayer(id, data) {
            const el = document.getElementById(`player-${id}`);
            if (el) {
                // IMPORTANT: The parent 'el' stays at 0,0,0 relative to world-root
                // We move the parts individually based on the data
                
                // Move Indicator (Head HUD)
                if (el.childNodes[0]) {
                     el.childNodes[0].object3D.position.set(data.x, data.y, data.z);
                     // We sync rotation so the indicator can turn with the head? 
                     // Or keep it billboarded? User asked for "static".
                     // Ideally it follows head rotation Y (Yaw) but stays upright.
                     el.childNodes[0].object3D.rotation.set(0, data.rotY, 0); 
                     
                     // If it's the Red Triangle (Cone), we need to maintain the 180 flip
                     if (data.team !== 'blue') {
                        el.childNodes[0].object3D.rotation.x = Math.PI; // Keep pointing down
                     }
                }
                
                // Move Hand (Weapon)
                const hand = el.querySelector('.remote-hand');
                if (hand && data.handX !== undefined) {
                    hand.object3D.position.set(data.handX, data.handY, data.handZ);
                    hand.object3D.rotation.set(data.handRotX, data.handRotY, data.handRotZ);
                }
            }
        }

        function removeRemotePlayer(id) {
            const el = document.getElementById(`player-${id}`);
            if (el) el.remove();
        }
    </script>
</body>
</html>
